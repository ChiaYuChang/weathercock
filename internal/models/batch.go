// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package models

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/pgvector/pgvector-go"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const insertChunksBatch = `-- name: InsertChunksBatch :batchexec
INSERT INTO users.chunks (
    article_id,
    "start",
    offset_left,
    offset_right,
    "end"
) VALUES (
    $1, 
    $2,
    $3,
    $4,
    $5
) 
ON CONFLICT DO NOTHING
RETURNING id
`

type InsertChunksBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertChunksBatchParams struct {
	ArticleID   int32 `db:"article_id" json:"article_id"`
	Start       int32 `db:"start" json:"start"`
	OffsetLeft  int32 `db:"offset_left" json:"offset_left"`
	OffsetRight int32 `db:"offset_right" json:"offset_right"`
	End         int32 `db:"end" json:"end"`
}

func (q *Queries) InsertChunksBatch(ctx context.Context, arg []InsertChunksBatchParams) *InsertChunksBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ArticleID,
			a.Start,
			a.OffsetLeft,
			a.OffsetRight,
			a.End,
		}
		batch.Queue(insertChunksBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertChunksBatchBatchResults{br, len(arg), false}
}

func (b *InsertChunksBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertChunksBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertEmbeddingBatch = `-- name: InsertEmbeddingBatch :batchexec
INSERT INTO embeddings (
    article_id,
    chunk_id,
    model_id,
    vector
) VALUES (
    $1, 
    $2,
    $3,
    $4::vector
)
ON CONFLICT DO NOTHING
RETURNING id
`

type InsertEmbeddingBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertEmbeddingBatchParams struct {
	ArticleID int32           `db:"article_id" json:"article_id"`
	ChunkID   int32           `db:"chunk_id" json:"chunk_id"`
	ModelID   int32           `db:"model_id" json:"model_id"`
	Vector    pgvector.Vector `db:"vector" json:"vector"`
}

func (q *Queries) InsertEmbeddingBatch(ctx context.Context, arg []InsertEmbeddingBatchParams) *InsertEmbeddingBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ArticleID,
			a.ChunkID,
			a.ModelID,
			a.Vector,
		}
		batch.Queue(insertEmbeddingBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertEmbeddingBatchBatchResults{br, len(arg), false}
}

func (b *InsertEmbeddingBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertEmbeddingBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertUserChunksBatch = `-- name: InsertUserChunksBatch :batchexec
INSERT INTO users.chunks (
    article_id,
    "start",
    offset_left,
    offset_right,
    "end"
) VALUES (
    $1, 
    $2,
    $3,
    $4,
    $5
) 
ON CONFLICT DO NOTHING
RETURNING id
`

type InsertUserChunksBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertUserChunksBatchParams struct {
	ArticleID   int32 `db:"article_id" json:"article_id"`
	Start       int32 `db:"start" json:"start"`
	OffsetLeft  int32 `db:"offset_left" json:"offset_left"`
	OffsetRight int32 `db:"offset_right" json:"offset_right"`
	End         int32 `db:"end" json:"end"`
}

func (q *Queries) InsertUserChunksBatch(ctx context.Context, arg []InsertUserChunksBatchParams) *InsertUserChunksBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ArticleID,
			a.Start,
			a.OffsetLeft,
			a.OffsetRight,
			a.End,
		}
		batch.Queue(insertUserChunksBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertUserChunksBatchBatchResults{br, len(arg), false}
}

func (b *InsertUserChunksBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertUserChunksBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

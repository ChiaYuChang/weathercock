// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: articles.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const extractChunks = `-- name: ExtractChunks :many
SELECT c.article_id AS article_id,
    c.id AS chunk_id,
    substring(
        a.content
        FROM c."start" + 1 FOR (c."end" - c."start")
    ) AS content
FROM articles AS a
    JOIN chunks AS c ON a.id = c.article_id
WHERE a.id = $1
ORDER BY c."start"
`

type ExtractChunksRow struct {
	ArticleID int32       `db:"article_id" json:"article_id"`
	ChunkID   int32       `db:"chunk_id" json:"chunk_id"`
	Content   pgtype.Bits `db:"content" json:"content"`
}

func (q *Queries) ExtractChunks(ctx context.Context, id int32) ([]ExtractChunksRow, error) {
	rows, err := q.db.Query(ctx, extractChunks, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtractChunksRow
	for rows.Next() {
		var i ExtractChunksRow
		if err := rows.Scan(&i.ArticleID, &i.ChunkID, &i.Content); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const extractUsersChunks = `-- name: ExtractUsersChunks :many
SELECT c.article_id AS article_id,
    c.id AS chunk_id,
    substring(
        a.content
        FROM c."start" + 1 FOR (c."end" - c."start")
    ) AS content
FROM users.articles AS a
    JOIN users.chunks AS c ON a.id = c.article_id
WHERE a.id = $1
ORDER BY c."start"
`

type ExtractUsersChunksRow struct {
	ArticleID int32       `db:"article_id" json:"article_id"`
	ChunkID   int32       `db:"chunk_id" json:"chunk_id"`
	Content   pgtype.Bits `db:"content" json:"content"`
}

func (q *Queries) ExtractUsersChunks(ctx context.Context, id int32) ([]ExtractUsersChunksRow, error) {
	rows, err := q.db.Query(ctx, extractUsersChunks, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtractUsersChunksRow
	for rows.Next() {
		var i ExtractUsersChunksRow
		if err := rows.Scan(&i.ArticleID, &i.ChunkID, &i.Content); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticleByID = `-- name: GetArticleByID :one
SELECT id, title, url, source, md5, party, content, cuts, published_at, created_at
FROM articles
WHERE id = $1
`

func (q *Queries) GetArticleByID(ctx context.Context, id int32) (Article, error) {
	row := q.db.QueryRow(ctx, getArticleByID, id)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Url,
		&i.Source,
		&i.Md5,
		&i.Party,
		&i.Content,
		&i.Cuts,
		&i.PublishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getArticleByIDs = `-- name: GetArticleByIDs :many
SELECT id, title, url, source, md5, party, content, cuts, published_at, created_at
FROM articles
WHERE id = ANY($1::integer[])
`

func (q *Queries) GetArticleByIDs(ctx context.Context, ids []int32) ([]Article, error) {
	rows, err := q.db.Query(ctx, getArticleByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Url,
			&i.Source,
			&i.Md5,
			&i.Party,
			&i.Content,
			&i.Cuts,
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticleByMD5 = `-- name: GetArticleByMD5 :one
SELECT id, title, url, source, md5, party, content, cuts, published_at, created_at
FROM articles
WHERE md5 = $1
`

func (q *Queries) GetArticleByMD5(ctx context.Context, md5 string) (Article, error) {
	row := q.db.QueryRow(ctx, getArticleByMD5, md5)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Url,
		&i.Source,
		&i.Md5,
		&i.Party,
		&i.Content,
		&i.Cuts,
		&i.PublishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getArticleByURL = `-- name: GetArticleByURL :one
SELECT id, title, url, source, md5, party, content, cuts, published_at, created_at
FROM articles
WHERE "url" = $1
ORDER BY published_at DESC
LIMIT 1
`

func (q *Queries) GetArticleByURL(ctx context.Context, url string) (Article, error) {
	row := q.db.QueryRow(ctx, getArticleByURL, url)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Url,
		&i.Source,
		&i.Md5,
		&i.Party,
		&i.Content,
		&i.Cuts,
		&i.PublishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getArticleWithinTimeInterval = `-- name: GetArticleWithinTimeInterval :many
SELECT id, title, url, source, md5, party, content, cuts, published_at, created_at
FROM articles
WHERE published_at BETWEEN $1 AND $2
ORDER BY published_at DESC
LIMIT $3::integer
`

type GetArticleWithinTimeIntervalParams struct {
	Start pgtype.Timestamptz `db:"start" json:"start"`
	End   pgtype.Timestamptz `db:"end" json:"end"`
	Limit int32              `db:"limit" json:"limit"`
}

func (q *Queries) GetArticleWithinTimeInterval(ctx context.Context, arg GetArticleWithinTimeIntervalParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getArticleWithinTimeInterval, arg.Start, arg.End, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Url,
			&i.Source,
			&i.Md5,
			&i.Party,
			&i.Content,
			&i.Cuts,
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticlesInPastKDays = `-- name: GetArticlesInPastKDays :many
SELECT id, title, url, source, md5, party, content, cuts, published_at, created_at
FROM articles
WHERE published_at >= NOW() - INTERVAL '1 day' * $1::integer
ORDER BY published_at DESC
LIMIT $2::integer
`

type GetArticlesInPastKDaysParams struct {
	K     int32 `db:"k" json:"k"`
	Limit int32 `db:"limit" json:"limit"`
}

func (q *Queries) GetArticlesInPastKDays(ctx context.Context, arg GetArticlesInPastKDaysParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, getArticlesInPastKDays, arg.K, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Url,
			&i.Source,
			&i.Md5,
			&i.Party,
			&i.Content,
			&i.Cuts,
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersArticleByID = `-- name: GetUsersArticleByID :one
SELECT id, task_id, title, url, source, md5, content, cuts, published_at, created_at
FROM users.articles
WHERE id = $1
`

func (q *Queries) GetUsersArticleByID(ctx context.Context, id int32) (UsersArticle, error) {
	row := q.db.QueryRow(ctx, getUsersArticleByID, id)
	var i UsersArticle
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Url,
		&i.Source,
		&i.Md5,
		&i.Content,
		&i.Cuts,
		&i.PublishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUsersArticleByMD5 = `-- name: GetUsersArticleByMD5 :one
SELECT id, task_id, title, url, source, md5, content, cuts, published_at, created_at
FROM users.articles
WHERE md5 = $1
`

func (q *Queries) GetUsersArticleByMD5(ctx context.Context, md5 string) (UsersArticle, error) {
	row := q.db.QueryRow(ctx, getUsersArticleByMD5, md5)
	var i UsersArticle
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Url,
		&i.Source,
		&i.Md5,
		&i.Content,
		&i.Cuts,
		&i.PublishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUsersArticleByTaskID = `-- name: GetUsersArticleByTaskID :one
SELECT id, task_id, title, url, source, md5, content, cuts, published_at, created_at
FROM users.articles
WHERE task_id = $1
`

func (q *Queries) GetUsersArticleByTaskID(ctx context.Context, taskID uuid.UUID) (UsersArticle, error) {
	row := q.db.QueryRow(ctx, getUsersArticleByTaskID, taskID)
	var i UsersArticle
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Url,
		&i.Source,
		&i.Md5,
		&i.Content,
		&i.Cuts,
		&i.PublishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const insertArticle = `-- name: InsertArticle :one
INSERT INTO articles (
        title,
        "url",
        source,
        md5,
        party,
        content,
        cuts,
        published_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
RETURNING id
`

type InsertArticleParams struct {
	Title       string             `db:"title" json:"title"`
	Url         string             `db:"url" json:"url"`
	Source      string             `db:"source" json:"source"`
	Md5         string             `db:"md5" json:"md5"`
	Party       Party              `db:"party" json:"party"`
	Content     string             `db:"content" json:"content"`
	Cuts        []int32            `db:"cuts" json:"cuts"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"published_at"`
}

func (q *Queries) InsertArticle(ctx context.Context, arg InsertArticleParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertArticle,
		arg.Title,
		arg.Url,
		arg.Source,
		arg.Md5,
		arg.Party,
		arg.Content,
		arg.Cuts,
		arg.PublishedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertChunk = `-- name: InsertChunk :one
INSERT INTO chunks (
        article_id,
        "start",
        offset_left,
        offset_right,
        "end"
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertChunkParams struct {
	ArticleID   int32 `db:"article_id" json:"article_id"`
	Start       int32 `db:"start" json:"start"`
	OffsetLeft  int32 `db:"offset_left" json:"offset_left"`
	OffsetRight int32 `db:"offset_right" json:"offset_right"`
	End         int32 `db:"end" json:"end"`
}

func (q *Queries) InsertChunk(ctx context.Context, arg InsertChunkParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertChunk,
		arg.ArticleID,
		arg.Start,
		arg.OffsetLeft,
		arg.OffsetRight,
		arg.End,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertTestUserArticle = `-- name: InsertTestUserArticle :one
INSERT INTO users.articles (
        task_id,
        title,
        "url",
        source,
        md5,
        content,
        cuts,
        published_at,
        created_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    )
RETURNING id
`

type InsertTestUserArticleParams struct {
	TaskID      uuid.UUID          `db:"task_id" json:"task_id"`
	Title       string             `db:"title" json:"title"`
	Url         string             `db:"url" json:"url"`
	Source      string             `db:"source" json:"source"`
	Md5         string             `db:"md5" json:"md5"`
	Content     string             `db:"content" json:"content"`
	Cuts        []int32            `db:"cuts" json:"cuts"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"published_at"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) InsertTestUserArticle(ctx context.Context, arg InsertTestUserArticleParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertTestUserArticle,
		arg.TaskID,
		arg.Title,
		arg.Url,
		arg.Source,
		arg.Md5,
		arg.Content,
		arg.Cuts,
		arg.PublishedAt,
		arg.CreatedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertUsersArticle = `-- name: InsertUsersArticle :one
INSERT INTO users.articles (
        task_id,
        title,
        "url",
        source,
        md5,
        content,
        cuts,
        published_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
RETURNING id
`

type InsertUsersArticleParams struct {
	TaskID      uuid.UUID          `db:"task_id" json:"task_id"`
	Title       string             `db:"title" json:"title"`
	Url         string             `db:"url" json:"url"`
	Source      string             `db:"source" json:"source"`
	Md5         string             `db:"md5" json:"md5"`
	Content     string             `db:"content" json:"content"`
	Cuts        []int32            `db:"cuts" json:"cuts"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"published_at"`
}

func (q *Queries) InsertUsersArticle(ctx context.Context, arg InsertUsersArticleParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertUsersArticle,
		arg.TaskID,
		arg.Title,
		arg.Url,
		arg.Source,
		arg.Md5,
		arg.Content,
		arg.Cuts,
		arg.PublishedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertUsersChunk = `-- name: InsertUsersChunk :one
INSERT INTO users.chunks (
        article_id,
        "start",
        offset_left,
        offset_right,
        "end"
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertUsersChunkParams struct {
	ArticleID   int32 `db:"article_id" json:"article_id"`
	Start       int32 `db:"start" json:"start"`
	OffsetLeft  int32 `db:"offset_left" json:"offset_left"`
	OffsetRight int32 `db:"offset_right" json:"offset_right"`
	End         int32 `db:"end" json:"end"`
}

func (q *Queries) InsertUsersChunk(ctx context.Context, arg InsertUsersChunkParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertUsersChunk,
		arg.ArticleID,
		arg.Start,
		arg.OffsetLeft,
		arg.OffsetRight,
		arg.End,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package models

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/pgvector/pgvector-go"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const insertChunksBatch = `-- name: InsertChunksBatch :batchone
INSERT INTO users.chunks (
        article_id,
        "start",
        offset_left,
        offset_right,
        "end"
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING
RETURNING id
`

type InsertChunksBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertChunksBatchParams struct {
	ArticleID   int32 `db:"article_id" json:"article_id"`
	Start       int32 `db:"start" json:"start"`
	OffsetLeft  int32 `db:"offset_left" json:"offset_left"`
	OffsetRight int32 `db:"offset_right" json:"offset_right"`
	End         int32 `db:"end" json:"end"`
}

func (q *Queries) InsertChunksBatch(ctx context.Context, arg []InsertChunksBatchParams) *InsertChunksBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ArticleID,
			a.Start,
			a.OffsetLeft,
			a.OffsetRight,
			a.End,
		}
		batch.Queue(insertChunksBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertChunksBatchBatchResults{br, len(arg), false}
}

func (b *InsertChunksBatchBatchResults) QueryRow(f func(int, int32, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var id int32
		if b.closed {
			if f != nil {
				f(t, id, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&id)
		if f != nil {
			f(t, id, err)
		}
	}
}

func (b *InsertChunksBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertEmbeddingBatch = `-- name: InsertEmbeddingBatch :batchone
INSERT INTO embeddings (
        article_id,
        chunk_id,
        model_id,
        vector
    )
VALUES ($1, $2, $3, $4::vector) ON CONFLICT DO NOTHING
RETURNING id
`

type InsertEmbeddingBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertEmbeddingBatchParams struct {
	ArticleID int32           `db:"article_id" json:"article_id"`
	ChunkID   int32           `db:"chunk_id" json:"chunk_id"`
	ModelID   int32           `db:"model_id" json:"model_id"`
	Vector    pgvector.Vector `db:"vector" json:"vector"`
}

func (q *Queries) InsertEmbeddingBatch(ctx context.Context, arg []InsertEmbeddingBatchParams) *InsertEmbeddingBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ArticleID,
			a.ChunkID,
			a.ModelID,
			a.Vector,
		}
		batch.Queue(insertEmbeddingBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertEmbeddingBatchBatchResults{br, len(arg), false}
}

func (b *InsertEmbeddingBatchBatchResults) QueryRow(f func(int, int32, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var id int32
		if b.closed {
			if f != nil {
				f(t, id, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&id)
		if f != nil {
			f(t, id, err)
		}
	}
}

func (b *InsertEmbeddingBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertUsersChunksBatch = `-- name: InsertUsersChunksBatch :batchone
INSERT INTO users.chunks (
        article_id,
        "start",
        offset_left,
        offset_right,
        "end"
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING
RETURNING id
`

type InsertUsersChunksBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertUsersChunksBatchParams struct {
	ArticleID   int32 `db:"article_id" json:"article_id"`
	Start       int32 `db:"start" json:"start"`
	OffsetLeft  int32 `db:"offset_left" json:"offset_left"`
	OffsetRight int32 `db:"offset_right" json:"offset_right"`
	End         int32 `db:"end" json:"end"`
}

func (q *Queries) InsertUsersChunksBatch(ctx context.Context, arg []InsertUsersChunksBatchParams) *InsertUsersChunksBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ArticleID,
			a.Start,
			a.OffsetLeft,
			a.OffsetRight,
			a.End,
		}
		batch.Queue(insertUsersChunksBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertUsersChunksBatchBatchResults{br, len(arg), false}
}

func (b *InsertUsersChunksBatchBatchResults) QueryRow(f func(int, int32, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var id int32
		if b.closed {
			if f != nil {
				f(t, id, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&id)
		if f != nil {
			f(t, id, err)
		}
	}
}

func (b *InsertUsersChunksBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertUsersEmbeddingBatch = `-- name: InsertUsersEmbeddingBatch :batchone
INSERT INTO users.embeddings (
        article_id,
        chunk_id,
        model_id,
        vector
    )
VALUES ($1, $2, $3, $4::vector) ON CONFLICT DO NOTHING
RETURNING id
`

type InsertUsersEmbeddingBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertUsersEmbeddingBatchParams struct {
	ArticleID int32           `db:"article_id" json:"article_id"`
	ChunkID   int32           `db:"chunk_id" json:"chunk_id"`
	ModelID   int32           `db:"model_id" json:"model_id"`
	Vector    pgvector.Vector `db:"vector" json:"vector"`
}

func (q *Queries) InsertUsersEmbeddingBatch(ctx context.Context, arg []InsertUsersEmbeddingBatchParams) *InsertUsersEmbeddingBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ArticleID,
			a.ChunkID,
			a.ModelID,
			a.Vector,
		}
		batch.Queue(insertUsersEmbeddingBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertUsersEmbeddingBatchBatchResults{br, len(arg), false}
}

func (b *InsertUsersEmbeddingBatchBatchResults) QueryRow(f func(int, int32, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var id int32
		if b.closed {
			if f != nil {
				f(t, id, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&id)
		if f != nil {
			f(t, id, err)
		}
	}
}

func (b *InsertUsersEmbeddingBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

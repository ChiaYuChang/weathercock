// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: articles.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (
    title,
    "url",
    source,
    md5,
    party,
    content,
    paragraph_starts,
    published_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING id
`

type CreateArticleParams struct {
	Title           string             `db:"title" json:"title"`
	Url             string             `db:"url" json:"url"`
	Source          string             `db:"source" json:"source"`
	Md5             string             `db:"md5" json:"md5"`
	Party           Party              `db:"party" json:"party"`
	Content         string             `db:"content" json:"content"`
	ParagraphStarts []int32            `db:"paragraph_starts" json:"paragraph_starts"`
	PublishedAt     pgtype.Timestamptz `db:"published_at" json:"published_at"`
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (int32, error) {
	row := q.db.QueryRow(ctx, createArticle,
		arg.Title,
		arg.Url,
		arg.Source,
		arg.Md5,
		arg.Party,
		arg.Content,
		arg.ParagraphStarts,
		arg.PublishedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createChunk = `-- name: CreateChunk :one
INSERT INTO chunks (
    article_id,
    "start",
    offset_left,
    offset_right,
    "end"
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) RETURNING id
`

type CreateChunkParams struct {
	ArticleID   int32 `db:"article_id" json:"article_id"`
	Start       int32 `db:"start" json:"start"`
	OffsetLeft  int32 `db:"offset_left" json:"offset_left"`
	OffsetRight int32 `db:"offset_right" json:"offset_right"`
	End         int32 `db:"end" json:"end"`
}

func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (int32, error) {
	row := q.db.QueryRow(ctx, createChunk,
		arg.ArticleID,
		arg.Start,
		arg.OffsetLeft,
		arg.OffsetRight,
		arg.End,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUserArticle = `-- name: CreateUserArticle :one
INSERT INTO users.articles (
    task_id,
    title,
    "url",
    source,
    md5,
    content,
    paragraph_starts,
    published_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING id
`

type CreateUserArticleParams struct {
	TaskID          uuid.UUID          `db:"task_id" json:"task_id"`
	Title           string             `db:"title" json:"title"`
	Url             string             `db:"url" json:"url"`
	Source          string             `db:"source" json:"source"`
	Md5             string             `db:"md5" json:"md5"`
	Content         string             `db:"content" json:"content"`
	ParagraphStarts []int32            `db:"paragraph_starts" json:"paragraph_starts"`
	PublishedAt     pgtype.Timestamptz `db:"published_at" json:"published_at"`
}

func (q *Queries) CreateUserArticle(ctx context.Context, arg CreateUserArticleParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUserArticle,
		arg.TaskID,
		arg.Title,
		arg.Url,
		arg.Source,
		arg.Md5,
		arg.Content,
		arg.ParagraphStarts,
		arg.PublishedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createUserChunk = `-- name: CreateUserChunk :one
INSERT INTO users.chunks (
    article_id,
    "start",
    offset_left,
    offset_right,
    "end"
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) RETURNING id
`

type CreateUserChunkParams struct {
	ArticleID   int32 `db:"article_id" json:"article_id"`
	Start       int32 `db:"start" json:"start"`
	OffsetLeft  int32 `db:"offset_left" json:"offset_left"`
	OffsetRight int32 `db:"offset_right" json:"offset_right"`
	End         int32 `db:"end" json:"end"`
}

func (q *Queries) CreateUserChunk(ctx context.Context, arg CreateUserChunkParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUserChunk,
		arg.ArticleID,
		arg.Start,
		arg.OffsetLeft,
		arg.OffsetRight,
		arg.End,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const extractChunks = `-- name: ExtractChunks :many
SELECT
    c.article_id AS article_id,
    c.id AS chunk_id,
    substring(
        a.content 
        FROM c."start" + 1
        FOR (c."end" - c."start")
    ) AS content
FROM
    articles AS a
JOIN
    chunks AS c
ON 
    a.id = c.article_id
WHERE
    a.id = $1
ORDER BY
    c."start"
`

type ExtractChunksRow struct {
	ArticleID int32       `db:"article_id" json:"article_id"`
	ChunkID   int32       `db:"chunk_id" json:"chunk_id"`
	Content   pgtype.Bits `db:"content" json:"content"`
}

func (q *Queries) ExtractChunks(ctx context.Context, id int32) ([]ExtractChunksRow, error) {
	rows, err := q.db.Query(ctx, extractChunks, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtractChunksRow
	for rows.Next() {
		var i ExtractChunksRow
		if err := rows.Scan(&i.ArticleID, &i.ChunkID, &i.Content); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const extractUserChunks = `-- name: ExtractUserChunks :many
SELECT
    c.article_id AS article_id,
    c.id AS chunk_id,
    substring(
        a.content 
        FROM c."start" + 1
        FOR (c."end" - c."start")
    ) AS content
FROM
    users.articles AS a
JOIN
    users.chunks AS c
ON 
    a.id = c.article_id
WHERE
    a.id = $1
ORDER BY
    c."start"
`

type ExtractUserChunksRow struct {
	ArticleID int32       `db:"article_id" json:"article_id"`
	ChunkID   int32       `db:"chunk_id" json:"chunk_id"`
	Content   pgtype.Bits `db:"content" json:"content"`
}

func (q *Queries) ExtractUserChunks(ctx context.Context, id int32) ([]ExtractUserChunksRow, error) {
	rows, err := q.db.Query(ctx, extractUserChunks, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtractUserChunksRow
	for rows.Next() {
		var i ExtractUserChunksRow
		if err := rows.Scan(&i.ArticleID, &i.ChunkID, &i.Content); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

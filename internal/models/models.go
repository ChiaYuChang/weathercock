// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package models

import (
	"database/sql/driver"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type Party string

const (
	PartyNone Party = "none"
	PartyKMT  Party = "KMT"
	PartyDPP  Party = "DPP"
	PartyTPP  Party = "TPP"
)

func (e *Party) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Party(s)
	case string:
		*e = Party(s)
	default:
		return fmt.Errorf("unsupported scan type for Party: %T", src)
	}
	return nil
}

type NullParty struct {
	Party Party `json:"party"`
	Valid bool  `json:"valid"` // Valid is true if Party is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParty) Scan(value interface{}) error {
	if value == nil {
		ns.Party, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Party.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParty) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Party), nil
}

func (e Party) Valid() bool {
	switch e {
	case PartyNone,
		PartyKMT,
		PartyDPP,
		PartyTPP:
		return true
	}
	return false
}

type SourceType string

const (
	SourceTypeUrl  SourceType = "url"
	SourceTypeText SourceType = "text"
)

func (e *SourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SourceType(s)
	case string:
		*e = SourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for SourceType: %T", src)
	}
	return nil
}

type NullSourceType struct {
	SourceType SourceType `json:"source_type"`
	Valid      bool       `json:"valid"` // Valid is true if SourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSourceType) Scan(value interface{}) error {
	if value == nil {
		ns.SourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SourceType), nil
}

func (e SourceType) Valid() bool {
	switch e {
	case SourceTypeUrl,
		SourceTypeText:
		return true
	}
	return false
}

type TaskStatus string

const (
	TaskStatusPending    TaskStatus = "pending"
	TaskStatusProcessing TaskStatus = "processing"
	TaskStatusDone       TaskStatus = "done"
	TaskStatusFailed     TaskStatus = "failed"
)

func (e *TaskStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TaskStatus(s)
	case string:
		*e = TaskStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TaskStatus: %T", src)
	}
	return nil
}

type NullTaskStatus struct {
	TaskStatus TaskStatus `json:"task_status"`
	Valid      bool       `json:"valid"` // Valid is true if TaskStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTaskStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TaskStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TaskStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTaskStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TaskStatus), nil
}

func (e TaskStatus) Valid() bool {
	switch e {
	case TaskStatusPending,
		TaskStatusProcessing,
		TaskStatusDone,
		TaskStatusFailed:
		return true
	}
	return false
}

type Article struct {
	ID          int32              `db:"id" json:"id"`
	Title       string             `db:"title" json:"title"`
	Url         string             `db:"url" json:"url"`
	Source      string             `db:"source" json:"source"`
	Md5         string             `db:"md5" json:"md5"`
	Party       Party              `db:"party" json:"party"`
	Content     string             `db:"content" json:"content"`
	Cuts        []int32            `db:"cuts" json:"cuts"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"published_at"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type ArticlesKeyword struct {
	ArticleID int32 `db:"article_id" json:"article_id"`
	KeywordID int32 `db:"keyword_id" json:"keyword_id"`
}

type Chunk struct {
	ID          int32              `db:"id" json:"id"`
	ArticleID   int32              `db:"article_id" json:"article_id"`
	Start       int32              `db:"start" json:"start"`
	OffsetLeft  int32              `db:"offset_left" json:"offset_left"`
	OffsetRight int32              `db:"offset_right" json:"offset_right"`
	End         int32              `db:"end" json:"end"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type Embedding struct {
	ID        int32              `db:"id" json:"id"`
	ArticleID int32              `db:"article_id" json:"article_id"`
	ChunkID   int32              `db:"chunk_id" json:"chunk_id"`
	ModelID   int32              `db:"model_id" json:"model_id"`
	Vector    interface{}        `db:"vector" json:"vector"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type Keyword struct {
	ID   int32  `db:"id" json:"id"`
	Term string `db:"term" json:"term"`
}

type Model struct {
	ID        int32              `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type SchemaMigration struct {
	Version int64 `db:"version" json:"version"`
	Dirty   bool  `db:"dirty" json:"dirty"`
}

type UsersArticle struct {
	ID          int32              `db:"id" json:"id"`
	TaskID      uuid.UUID          `db:"task_id" json:"task_id"`
	Title       string             `db:"title" json:"title"`
	Url         string             `db:"url" json:"url"`
	Source      string             `db:"source" json:"source"`
	Md5         string             `db:"md5" json:"md5"`
	Content     string             `db:"content" json:"content"`
	Cuts        []int32            `db:"cuts" json:"cuts"`
	PublishedAt pgtype.Timestamptz `db:"published_at" json:"published_at"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type UsersArticlesKeyword struct {
	ArticleID int32 `db:"article_id" json:"article_id"`
	KeywordID int32 `db:"keyword_id" json:"keyword_id"`
}

type UsersChunk struct {
	ID          int32              `db:"id" json:"id"`
	ArticleID   int32              `db:"article_id" json:"article_id"`
	Start       int32              `db:"start" json:"start"`
	OffsetLeft  int32              `db:"offset_left" json:"offset_left"`
	OffsetRight int32              `db:"offset_right" json:"offset_right"`
	End         int32              `db:"end" json:"end"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type UsersEmbedding struct {
	ID        int32              `db:"id" json:"id"`
	ArticleID int32              `db:"article_id" json:"article_id"`
	ChunkID   int32              `db:"chunk_id" json:"chunk_id"`
	ModelID   int32              `db:"model_id" json:"model_id"`
	Vector    interface{}        `db:"vector" json:"vector"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type UsersTask struct {
	ID            int32              `db:"id" json:"id"`
	TaskID        uuid.UUID          `db:"task_id" json:"task_id"`
	Source        SourceType         `db:"source" json:"source"`
	OriginalInput string             `db:"original_input" json:"original_input"`
	Status        TaskStatus         `db:"status" json:"status"`
	ErrorMessage  pgtype.Text        `db:"error_message" json:"error_message"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}
